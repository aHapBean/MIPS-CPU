`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 2023/05/10 10:01:40
// Design Name: 
// Module Name: instMemory
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module instMemory(
        input PC_Clk,
        input [31:0] address,
        output [31:0] readData
    );
    reg [31:0] memFile[0:63];
    integer i;
    initial begin
        //$readmemb("D:/Archlab/lab05/lab05.srcs/instruction",memFile);
        for(i = 0; i <= 63; i = i + 1)
            memFile[i] = 0;
        //test cases
        /*
        memFile[0] = 32'b10001100011000010000000000000000;  //lw $1, 0($3)
        memFile[1] = 32'b10001100011000100000000000000100;   //lw $2  4($3)
        memFile[2] = 32'b000000_00001_00010_00001_00000_100010; //  sub $1, $1 - $2
        memFile[3] = 32'b000100_00011_00001_0000000000000001;  //beq $1,$3,1
        memFile[4] = 32'b00001000000000000000000000000000; //j 0
        memFile[6] = 32'b101011_00011_00001_0000000000001000;//sw $1, 8($3)测试predictor*/
        //memFile[0] = 32'b10101100011010000000000000001000; //sw $8, 8($3)
        
        //$readmemb("E:/Archlab/lab06/instruction.txt",memFile);
        
        memFile[0] = 32'b10001100011000010000000000000000;  //lw $1, 0($3)
        memFile[1] = 32'b10001100011000100000000000000100;  //lw $2, 4($3)
        memFile[2] = 32'b00000000000000100010000001000010;
        memFile[3] = 32'b00000000000001000010100001000000;
        memFile[4] = 32'b00010000010001010000000000000001;
        memFile[5] = 32'b00000001000000010100000000100000;
        memFile[6] = 32'b00000000000000100001000001000010;
        memFile[7] = 32'b00000000000000010000100001000000;
        memFile[8] = 32'b00010000011000100000000000000001;
        memFile[9] = 32'b00001000000000000000000000000010;
        memFile[10] = 32'b10101100011010000000000000001000;
        
        //memFile[0] = 32'b000101_00000_00001_00000_00000_000100;//4 + 4 * 4 BNE $0,$1 这个由于用了$0和初始指令全0，所以会被STALL一个周期
        
        //memFile[0] = 32'b000101_00011_00001_00000_00000_000100;//4 + 4 * 4 BNE $0,$1 检查BNE
        //memFile[0] = 32'b000000_00001_00010_00001_00000_000100;//sllv $1,$2,$1 检查R型type
        
        //memFile[0] = 32'b10001100011000010000000000000000;  //lw $1, 0($3)
        //memFile[1] = 32'b10001100011000100000000000000000;  //lw $2, 0($3)
        //memFile[2] = 32'b00010000010000010000000000000010;  //往前跳2个
        /*
        设计预测测例
        memFile[0] = 32'b10001100011000010000000000000000;  //lw $1, 0($3)
        memFile[1] = 32'b10001100011000100000000000000100   //lw $2  4($3)
        memFile[2] = 32'b000000_00001_00010_00001_00000_100010 //  sub $1, $1 - $2
        memFile[3] = 32'b000100_00011_00001_0000000000000001;  //beq $1,$3,1
        memFile[4] = 32'b00001000000000000000000000000010; //j 8
        memFile[12] = 32'b101011_00011_00001_0000000000001000;//sw $1, 8($3)
        
        memFile[1] = 32'b000000_00011_00010_00001_00000_100010;//sub b000000_00011_00010_00001_00000_100010
        */
        /*
        memFile[0] = 32'b00001000000000000000000000000001; //j 4
        memFile[1] = 32'b00001000000000000000000000000010;
        memFile[2] = 32'b10001100011000010000000000000000;  //lw $1, 0($3)
        memFile[3] = 32'b10001100011000100000000000000100;  //lw $2, 4($3)
        memFile[4] = 32'b00000000000000100010000001000010;  //use after load
        memFile[5] = 32'b00000000000001000010100001000000;  //sll
        memFile[6] = 32'b00010000010001010000000000000001;  //beq $5,$2,1
        memFile[7] = 32'b00000001000000010100000000100000;
        memFile[8] = 32'b00000000000000100001000001000010;
        memFile[9] = 32'b00000000000000010000100001000000;
        memFile[10] = 32'b00010000011000100000000000000001;
        memFile[11] = 32'b00001000000000000000000000000100; //j 4
        memFile[12] = 32'b10101100011010000000000000001000; */
        /*
        //要forwarding全部正常前面至少两条
        memFile[0] = 32'b00001000000000000000000000000001;
        memFile[1] = 32'b00001000000000000000000000000010;   //jump 8 ! do sub jump没毛病，可以用
        //memFile[0] = 32'b000100_00001_00010_00000_00000_000010;//0+4+8
        memFile[2] = 32'b10001100011000100000000000000011;  //lw $2, 3($3)
        memFile[3] = 32'b000000_00011_00010_00001_00000_100000; //add 1 <- $2,$3
        //memFile[3] = 32'b000000_00001_00010_00011_00000_100000; //add 3 <- $1,$2
        memFile[4] = 32'b000000_00011_00010_00001_00000_100110; //xor 没有XOR这条指令
        memFile[5] = 32'b000000_00011_00010_00001_00000_100101; //or
        */
            /*
        memFile[0] = 32'b000000_00011_00010_00001_00000_100000;//寄存器加 add $1 <- $2,$3 b000000_00011_00010_00001_00000_100000
        memFile[1] = 32'b000000_00011_00010_00001_00000_100010;//sub b000000_00011_00010_00001_00000_100010
        memFile[2] = 32'b000000_00011_00010_00001_00000_100100;//and
        memFile[3] = 32'b000000_00011_00010_00001_00000_100101;//or
        memFile[4] = 32'b000000_00011_00010_00001_00000_100110;//xor b000000_00011_00010_00001_00000_100110
        memFile[5] = 32'b000000_00011_00010_00001_00000_101010;//slt
        memFile[6] = 32'b101011_00011_00010_00000_00000_001010;//sw $2,10($3) 
        memFile[7] = 32'b100011_00011_00001_00000_00000_001010;//lw $1,10($3)
        */
        /*
        自创测例1：
        00000000011000100000100000100000
        00000000011000100000100000100010
        00000000011000100000100000100100
        00000000011000100000100000100101
        00000000011000100000100000100110
        00000000011000100000100000101010
        10101100011000100000000000001010
        10001100011000010000000000001010
        */
        //memFile[8] = 
    end
    assign readData = ((address >> 2) > 10) ? 32'b0 : memFile[(address >> 2)];//here !!!!!
endmodule
